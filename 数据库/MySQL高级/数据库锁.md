1. 表锁

    * 偏向MyISAM存储引擎，开销小，加锁快；锁定力度大，发生锁冲突概率高，并发效率低；

    * MyISAM在执行查询语句前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及的表加写锁
    
    * 读锁会阻塞写，但不会阻塞读，而写锁会把读和写都阻塞
    
    * 当前会话给表加锁后不可以操作其他没加锁表
    
    ~~~mysql
    #加锁
lock table my_table read/write;
    #查看是否加锁
    show open tables;
    #释放锁
    unlock tables;
    ~~~
    
    ~~~mysql
    #分析表锁定
    show status like 'table%';
    #结果：
    Table_locks_immediate:产生表级锁定的次数，表示可以立即获取锁的查询次数，每次立即获取锁值加1
    Table_licks_waited:出现表级锁定竞争而发生等待的次数，此值越高说明存在较为严重的表级锁竞争情况
    ~~~
    
    MyISAM的读写锁调度是写优先，这也是MyISAM不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询难得到锁，从而造成永久阻塞。
    
2. 行锁

    * 偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁，锁定粒度最小，发生所冲突的概率最低，并发度也最高

    * 索引失效行锁会升级为表锁

    * 间隙锁的危害

        ~~~
        当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁;对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)"，
        InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间除锁(Next-Key锁)
        
        危害：
        因为Query执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在.
        间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即位某些不存在的键值也会被无辜的锁定.而造成在锁定的时候无法插入锁定键值范围内的任何数据.在某些场景下这可能会对性能造成很大的危害
        ~~~

    * 如何锁定一行

        ~~~mysql
        #手动提交
        begin;
        select * from table_name where a=8 for update;
        commit;
        ~~~

    * Innodb存储引擎户于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了
        但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。

    ~~~mysql
    #分析锁
    show status like 'innodb row lock%;
    Innodb_row_lock_current_waits:当前正在等待锁定的数量;
    Innodb_row_lock_waits:系统启动后到现在总共等待的次数;
    Innodb_row_lock_time_avg:每次等待所花平均时间;
    ~~~

3. 优化建议

    * 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁。
    * 合理设计索引，尽量缩小锁的范围
    * 尽可能较少检索条件，避免间隙锁
    * 尽量控制事务大小，减少锁定资源量和时间长度
    * 尽可能低级别事务隔离

